name: update-changelog.yml
on:
  workflow_dispatch:


jobs:
  update-changelog:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
      - uses: actions/github-script@v8
        with:
          script: |
            const title = 'Changelog'
            const filePath = 'CHANGELOG.md'
            
            const maxSemver = (() => {
              const refName = '${{ github.ref_name }}'
              return /^\d+\.\d+$/.test(refName) ? refName : null
            })()

            const owner = '${{ github.repository_owner }}'
            const repo = '${{ github.event.repository.name }}'

            const releasesResponse = await github.rest.repos.listReleases({
              owner,
              repo,
              per_page: 100,
            })
            const parseMajorMinor = (tag) => {
              const match = String(tag).trim().match(/^v?(\d+)\.(\d+)(?:\.\d+)?/)
              if (!match) return null
              return { major: Number(match[1]), minor: Number(match[2]) }
            }

            const parseSemver = (tag) => {
              const match = String(tag).trim().match(/^v?(\d+)\.(\d+)\.(\d+)/)
              if (!match) return null
              return { major: Number(match[1]), minor: Number(match[2]), patch: Number(match[3]) }
            }

            const compareSemverDesc = (a, b) => {
              if (!a && !b) return 0
              if (!a) return 1
              if (!b) return -1
              if (a.major !== b.major) return b.major - a.major
              if (a.minor !== b.minor) return b.minor - a.minor
              return b.patch - a.patch
            }

            const compareSemverAsc = (a, b) => -compareSemverDesc(a, b)

            const escapeRegExp = (s) => String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&')

            const normalizeBodyHeadings = (input) => {
              const text = String(input || '').replace(/\r\n/g, '\n')
              if (!text) return text

              const lines = text.split('\n')
              if (lines.length === 0) return text

              const headingMatch = (line) => line.match(/^(#{1,6})\s+(.*)$/)

              // Ensure the first line is always an H2.
              const firstHeading = headingMatch(lines[0])
              if (firstHeading) {
                lines[0] = `## ${firstHeading[2]}`
              } else {
                lines[0] = `## ${lines[0].trim()}`
              }

              // If any later headings are H1/H2, downgrade *all* later headings equally
              // so the minimum heading level becomes H3.
              let minLaterLevel = Infinity
              for (let i = 1; i < lines.length; i++) {
                const m = headingMatch(lines[i])
                if (!m) continue
                minLaterLevel = Math.min(minLaterLevel, m[1].length)
              }

              const delta = minLaterLevel <= 2 ? 3 - minLaterLevel : 0
              if (delta > 0) {
                for (let i = 1; i < lines.length; i++) {
                  const m = headingMatch(lines[i])
                  if (!m) continue
                  const newLevel = Math.min(6, m[1].length + delta)
                  lines[i] = `${'#'.repeat(newLevel)} ${m[2]}`
                }
              }

              return lines.join('\n')
            }

            const maxMajorMinor = maxSemver ? parseMajorMinor(maxSemver) : null
            const filteredReleases = releasesResponse.data
              .filter((release) => release.draft === false && release.prerelease === false)
              .filter((release) => {
                if (!maxMajorMinor) return true
                const mm = parseMajorMinor(release.tag_name)
                if (!mm) return false // non-semver tag; drop it
                return (
                  mm.major < maxMajorMinor.major ||
                  (mm.major === maxMajorMinor.major && mm.minor <= maxMajorMinor.minor)
                )
              })

            // Map each semver tag_name -> previous semver tag_name (based on semver ordering, not date ordering)
            const semverOrdered = filteredReleases
              .map((release) => ({ tag: String(release.tag_name || ''), semver: parseSemver(release.tag_name) }))
              .filter(({ semver }) => Boolean(semver))
              .sort((a, b) => compareSemverAsc(a.semver, b.semver))

            const prevTagByTag = new Map()
            for (let i = 0; i < semverOrdered.length; i++) {
              prevTagByTag.set(semverOrdered[i].tag, i > 0 ? semverOrdered[i - 1].tag : null)
            }

            const releases = filteredReleases
              .slice()
              .sort((a, b) => {
                const dayA = (a.published_at || '').slice(0, 10) // YYYY-MM-DD
                const dayB = (b.published_at || '').slice(0, 10)
                if (dayA !== dayB) return dayB.localeCompare(dayA) // desc
                return compareSemverDesc(parseSemver(a.tag_name), parseSemver(b.tag_name))
              })

            const bodies = releases
              .map((release) => {
                const tag = String(release.tag_name || '').trim()
                const semver = parseSemver(tag)
                const semverString = semver ? `${semver.major}.${semver.minor}.${semver.patch}` : null

                const rawBody = String(release.body || '')
                const body = rawBody.trim()
                if (!body) return ''

                if (!semverString) return normalizeBodyHeadings(body)

                const firstLine = rawBody.trimStart().split('\n')[0] || ''
                const semverInFirstLine = new RegExp(`\\bv?${escapeRegExp(semverString)}\\b`).test(firstLine)
                if (semverInFirstLine) return normalizeBodyHeadings(body)

                const prevTag = prevTagByTag.get(tag) || null
                const date = String(release.published_at || '').slice(0, 10)
                const base = `https://github.com/${owner}/${repo}`
                const link = prevTag ? `${base}/compare/${prevTag}...${tag}` : `${base}/releases/tag/${tag}`
                const header = `## [${semverString}](${link}) (${date})`

                return normalizeBodyHeadings(`${header}\n\n\n${body}`)
              })
              .filter(Boolean)

            const changelog = [`# ${title}`, ...bodies].join('\n\n') + '\n'

            console.log(changelog)
            
