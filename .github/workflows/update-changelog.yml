name: Update Changelog
on:
  workflow_dispatch:


jobs:
  update-changelog:
    permissions:
      contents: read
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - name: Generate Changelog
        id: generate-changelog
        uses: actions/github-script@v8
        with:
          result-encoding: string
          script: |
            // --- inputs / config ---
            const TITLE = 'Changelog'
            const MIN_SEMVER = '0.2.0'
            const MAX_SEMVER_BRANCH_RE = /^\d+\.\d+$/
            const RELEASES_PER_PAGE = 100

            // --- repo / env ---
            const { owner, repo } = context.repo
            const serverUrl = process.env.GITHUB_SERVER_URL || 'https://github.com'
            const baseRepoUrl = `${serverUrl}/${owner}/${repo}`
            const refName = process.env.GITHUB_REF_NAME || ''

            const maxSemver = MAX_SEMVER_BRANCH_RE.test(refName) ? refName : null

            // --- helpers ---
            const toDay = (iso) => String(iso || '').slice(0, 10) // YYYY-MM-DD
            const escapeRegExp = (s) => String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&')

            const parseMajorMinor = (tag) => {
              const m = String(tag).trim().match(/^v?(\d+)\.(\d+)(?:\.\d+)?/)
              return m ? { major: Number(m[1]), minor: Number(m[2]) } : null
            }

            const parseSemver = (tag) => {
              const m = String(tag).trim().match(/^v?(\d+)\.(\d+)\.(\d+)/)
              return m ? { major: Number(m[1]), minor: Number(m[2]), patch: Number(m[3]) } : null
            }

            const cmpSemverDesc = (a, b) => {
              if (!a && !b) return 0
              if (!a) return 1
              if (!b) return -1
              if (a.major !== b.major) return b.major - a.major
              if (a.minor !== b.minor) return b.minor - a.minor
              return b.patch - a.patch
            }
            const cmpSemverAsc = (a, b) => -cmpSemverDesc(a, b)

            const normalizeBodyHeadings = (input) => {
              const text = String(input || '').replace(/\r\n/g, '\n')
              if (!text) return text

              const lines = text.split('\n')
              if (lines.length === 0) return text

              const headingMatch = (line) => line.match(/^(#{1,6})\s+(.*)$/)

              // First line must be H2.
              const first = headingMatch(lines[0])
              lines[0] = first ? `## ${first[2]}` : `## ${lines[0].trim()}`

              // If any later heading is H1/H2, shift *all* later headings equally
              // so the minimum later heading becomes H3 (preserves hierarchy).
              let minLaterLevel = Infinity
              for (let i = 1; i < lines.length; i++) {
                const m = headingMatch(lines[i])
                if (m) minLaterLevel = Math.min(minLaterLevel, m[1].length)
              }

              const delta = minLaterLevel <= 2 ? 3 - minLaterLevel : 0
              if (delta > 0) {
                for (let i = 1; i < lines.length; i++) {
                  const m = headingMatch(lines[i])
                  if (!m) continue
                  const newLevel = Math.min(6, m[1].length + delta)
                  lines[i] = `${'#'.repeat(newLevel)} ${m[2]}`
                }
              }

              return lines.join('\n')
            }

            const minSemver = parseSemver(MIN_SEMVER)

            const isBelowMin = (tag) => {
              // If we can't parse semver, we can't reliably compare; keep prior behavior (don't drop).
              const semver = parseSemver(tag)
              if (!semver || !minSemver) return false
              return cmpSemverDesc(semver, minSemver) > 0 // semver < min
            }

            const shouldKeepUnderMax = (release) => {
              const maxMajorMinor = maxSemver ? parseMajorMinor(maxSemver) : null
              if (!maxMajorMinor) return true
              const mm = parseMajorMinor(release.tag_name)
              if (!mm) return false // if maxSemver is set, drop non-semver tags
              return (
                mm.major < maxMajorMinor.major ||
                (mm.major === maxMajorMinor.major && mm.minor <= maxMajorMinor.minor)
              )
            }

            const shouldKeepAboveMin = (release) => !isBelowMin(release.tag_name)

            const buildPrevTagMap = (releases) => {
              // previous tag is based on semver ordering, not publish date ordering
              const semverList = releases
                .map((r) => ({ tag: String(r.tag_name || ''), semver: parseSemver(r.tag_name) }))
                .filter((x) => Boolean(x.semver))
                .sort((a, b) => cmpSemverAsc(a.semver, b.semver))

              const prevByTag = new Map()
              for (let i = 0; i < semverList.length; i++) {
                prevByTag.set(semverList[i].tag, i > 0 ? semverList[i - 1].tag : null)
              }
              return prevByTag
            }

            const releaseHeader = ({ semverString, tag, date, prevTag }) => {
              const link = prevTag
                ? `${baseRepoUrl}/compare/${prevTag}...${tag}`
                : `${baseRepoUrl}/releases/tag/${tag}`
              return `## [${semverString}](${link}) (${date})`
            }

            const ensureHeaderIfMissing = (release, prevTagByTag) => {
              const tag = String(release.tag_name || '').trim()
              const semver = parseSemver(tag)
              const semverString = semver ? `${semver.major}.${semver.minor}.${semver.patch}` : null

              const rawBody = String(release.body || '')
              const trimmed = rawBody.trim()
              if (!trimmed) return ''

              // If tag isn't semver, just normalize headings.
              if (!semverString) return normalizeBodyHeadings(trimmed)

              // If first line already contains the semver (with optional "v"), don't add a header.
              const firstLine = rawBody.trimStart().split('\n')[0] || ''
              const semverInFirstLine = new RegExp(`\\bv?${escapeRegExp(semverString)}\\b`).test(firstLine)
              if (semverInFirstLine) return normalizeBodyHeadings(trimmed)

              const date = toDay(release.published_at)
              const prevTag = prevTagByTag.get(tag) || null
              const header = releaseHeader({ semverString, tag, date, prevTag })
              return normalizeBodyHeadings(`${header}\n\n\n${trimmed}`)
            }

            // --- fetch ---
            const releasesResponse = await github.rest.repos.listReleases({
              owner,
              repo,
              per_page: RELEASES_PER_PAGE,
            })

            // --- filter + sort ---
            const stable = releasesResponse.data.filter((r) => !r.draft && !r.prerelease)
            const filtered = stable.filter(shouldKeepAboveMin).filter(shouldKeepUnderMax)

            const prevTagByTag = buildPrevTagMap(filtered)

            const sorted = filtered.slice().sort((a, b) => {
              const dayA = toDay(a.published_at)
              const dayB = toDay(b.published_at)
              if (dayA !== dayB) return dayB.localeCompare(dayA) // date desc (day only)
              return cmpSemverDesc(parseSemver(a.tag_name), parseSemver(b.tag_name)) // semver desc
            })

            // --- render ---
            const bodies = sorted.map((r) => ensureHeaderIfMissing(r, prevTagByTag)).filter(Boolean)
            const changelog = [`# ${TITLE}`, ...bodies].join('\n\n') + '\n'

            console.log(changelog)
            return changelog

      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

