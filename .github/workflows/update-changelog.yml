name: Update Changelog
on:
  workflow_dispatch:


jobs:
  update-changelog:
    permissions:
      contents: read
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - name: Generate Changelog
        id: generate-changelog
        uses: actions/github-script@v8
        with:
          result-encoding: string
          script: |
            // --- inputs / config ---
            const TITLE = 'Changelog'
            const MIN_SEMVER = '0.2.0'
            const MAX_SEMVER_BRANCH_RE = /^\d+\.\d+$/
            const RELEASES_PER_PAGE = 100

            // --- repo / env ---
            const { owner, repo } = context.repo
            const serverUrl = process.env.GITHUB_SERVER_URL || 'https://github.com'
            const baseRepoUrl = `${serverUrl}/${owner}/${repo}`
            const refName = process.env.GITHUB_REF_NAME || ''

            const maxSemver = MAX_SEMVER_BRANCH_RE.test(refName) ? refName : null

            // --- helpers ---
            const toDay = (iso) => String(iso || '').slice(0, 10) // YYYY-MM-DD
            const escapeRegExp = (s) => String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&')

            const parseMajorMinor = (tag) => {
              const m = String(tag).trim().match(/^v?(\d+)\.(\d+)(?:\.\d+)?/)
              return m ? { major: Number(m[1]), minor: Number(m[2]) } : null
            }

            const parseSemver = (tag) => {
              const s = String(tag).trim()
              const m = s.match(
                /^v?(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+.*)?$/
              )
              if (!m) return null
              const prerelease = m[4] ? m[4].split('.') : null
              return {
                major: Number(m[1]),
                minor: Number(m[2]),
                patch: Number(m[3]),
                prerelease,
              }
            }

            const formatSemver = (s) => {
              if (!s) return null
              const base = `${s.major}.${s.minor}.${s.patch}`
              return s.prerelease && s.prerelease.length ? `${base}-${s.prerelease.join('.')}` : base
            }

            const isNumericIdentifier = (id) => /^[0-9]+$/.test(id)

            const cmpPrereleaseAsc = (aIds, bIds) => {
              const a = aIds || []
              const b = bIds || []
              const len = Math.max(a.length, b.length)
              for (let i = 0; i < len; i++) {
                const ai = a[i]
                const bi = b[i]
                if (ai === undefined && bi === undefined) return 0
                if (ai === undefined) return -1 // shorter set has lower precedence
                if (bi === undefined) return 1
                const aNum = isNumericIdentifier(ai)
                const bNum = isNumericIdentifier(bi)
                if (aNum && bNum) {
                  const diff = Number(ai) - Number(bi)
                  if (diff !== 0) return diff
                  continue
                }
                if (aNum !== bNum) return aNum ? -1 : 1 // numeric has lower precedence than non-numeric
                const cmp = String(ai).localeCompare(String(bi))
                if (cmp !== 0) return cmp
              }
              return 0
            }

            // SemVer precedence: compare major/minor/patch; then stable > prerelease; then prerelease identifiers.
            const cmpSemverAsc = (a, b) => {
              if (!a && !b) return 0
              if (!a) return -1
              if (!b) return 1
              if (a.major !== b.major) return a.major - b.major
              if (a.minor !== b.minor) return a.minor - b.minor
              if (a.patch !== b.patch) return a.patch - b.patch

              const aPre = a.prerelease && a.prerelease.length ? a.prerelease : null
              const bPre = b.prerelease && b.prerelease.length ? b.prerelease : null
              if (!aPre && !bPre) return 0
              if (!aPre) return 1 // stable has higher precedence than prerelease
              if (!bPre) return -1
              return cmpPrereleaseAsc(aPre, bPre)
            }

            const cmpSemverDesc = (a, b) => -cmpSemverAsc(a, b)

            const normalizeBodyHeadings = (input) => {
              const text = String(input || '').replace(/\r\n/g, '\n')
              if (!text) return text

              const lines = text.split('\n')
              if (lines.length === 0) return text

              const headingMatch = (line) => line.match(/^(#{1,6})\s+(.*)$/)

              // First line must be H2.
              const first = headingMatch(lines[0])
              lines[0] = first ? `## ${first[2]}` : `## ${lines[0].trim()}`

              // If any later heading is H1/H2, shift *all* later headings equally
              // so the minimum later heading becomes H3 (preserves hierarchy).
              let minLaterLevel = Infinity
              for (let i = 1; i < lines.length; i++) {
                const m = headingMatch(lines[i])
                if (m) minLaterLevel = Math.min(minLaterLevel, m[1].length)
              }

              const delta = minLaterLevel <= 2 ? 3 - minLaterLevel : 0
              if (delta > 0) {
                for (let i = 1; i < lines.length; i++) {
                  const m = headingMatch(lines[i])
                  if (!m) continue
                  const newLevel = Math.min(6, m[1].length + delta)
                  lines[i] = `${'#'.repeat(newLevel)} ${m[2]}`
                }
              }

              return lines.join('\n')
            }

            const minSemver = parseSemver(MIN_SEMVER)

            const isBelowMin = (tag) => {
              // If we can't parse semver, we can't reliably compare; keep prior behavior (don't drop).
              const semver = parseSemver(tag)
              if (!semver || !minSemver) return false
              return cmpSemverAsc(semver, minSemver) < 0 // semver < min
            }

            const shouldKeepUnderMax = (release) => {
              const maxMajorMinor = maxSemver ? parseMajorMinor(maxSemver) : null
              if (!maxMajorMinor) return true
              const mm = parseMajorMinor(release.tag_name)
              if (!mm) return false // if maxSemver is set, drop non-semver tags
              return (
                mm.major < maxMajorMinor.major ||
                (mm.major === maxMajorMinor.major && mm.minor <= maxMajorMinor.minor)
              )
            }

            const shouldKeepAboveMin = (release) => !isBelowMin(release.tag_name)

            const buildPrevTagMap = (releases) => {
              // previous tag is based on semver ordering, not publish date ordering
              const semverList = releases
                .map((r) => ({ tag: String(r.tag_name || ''), semver: parseSemver(r.tag_name) }))
                .filter((x) => Boolean(x.semver))
                .sort((a, b) => cmpSemverAsc(a.semver, b.semver))

              const prevByTag = new Map()
              for (let i = 0; i < semverList.length; i++) {
                prevByTag.set(semverList[i].tag, i > 0 ? semverList[i - 1].tag : null)
              }
              return prevByTag
            }

            const releaseHeader = ({ semverString, tag, date, prevTag }) => {
              const link = prevTag
                ? `${baseRepoUrl}/compare/${prevTag}...${tag}`
                : `${baseRepoUrl}/releases/tag/${tag}`
              return `## [${semverString}](${link}) (${date})`
            }

            const ensureHeaderIfMissing = (release, prevTagByTag) => {
              const tag = String(release.tag_name || '').trim()
              const semver = parseSemver(tag)
              const semverString = formatSemver(semver)

              const rawBody = String(release.body || '')
              const trimmed = rawBody.trim()
              if (!trimmed) return ''

              // If tag isn't semver, just normalize headings.
              if (!semverString) return normalizeBodyHeadings(trimmed)

              // If first line already contains the semver (with optional "v"), don't add a header.
              const firstLine = rawBody.trimStart().split('\n')[0] || ''
              const semverInFirstLine = new RegExp(`\\bv?${escapeRegExp(semverString)}\\b`).test(firstLine)
              if (semverInFirstLine) return normalizeBodyHeadings(trimmed)

              const date = toDay(release.published_at)
              const prevTag = prevTagByTag.get(tag) || null
              const header = releaseHeader({ semverString, tag, date, prevTag })
              return normalizeBodyHeadings(`${header}\n\n\n${trimmed}`)
            }

            // --- fetch ---
            const releasesResponse = await github.rest.repos.listReleases({
              owner,
              repo,
              per_page: RELEASES_PER_PAGE,
            })

            // --- filter + sort ---
            const published = releasesResponse.data.filter((r) => !r.draft)
            const filtered = published.filter(shouldKeepAboveMin).filter(shouldKeepUnderMax)

            const prevTagByTag = buildPrevTagMap(filtered)

            const sorted = filtered.slice().sort((a, b) => {
              const dayA = toDay(a.published_at)
              const dayB = toDay(b.published_at)
              if (dayA !== dayB) return dayB.localeCompare(dayA) // date desc (day only)
              if (Boolean(a.prerelease) !== Boolean(b.prerelease)) return a.prerelease ? 1 : -1 // stable first
              return cmpSemverDesc(parseSemver(a.tag_name), parseSemver(b.tag_name)) // semver desc (prerelease-aware)
            })

            // --- render ---
            const bodies = sorted.map((r) => ensureHeaderIfMissing(r, prevTagByTag)).filter(Boolean)
            const changelog = [`# ${TITLE}`, ...bodies].join('\n\n') + '\n'

            console.log(changelog)
            return changelog

      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

